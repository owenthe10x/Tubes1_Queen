// Import necessary libraries and modules
IMPORT random
IMPORT Optional type

// Import base logic for game
FROM game.logic.base IMPORT BaseLogic

// Import game models
FROM game.models IMPORT GameObject, Board, Position

// Import Position model
FROM current directory's models IMPORT Position

// Function to determine if the bot is in danger based on its position and the positions of enemies
FUNCTION am_i_in_danger(bot, enemies)
    // Iterate through each enemy in the enemies list
    FOR EACH enemy IN enemies
        // Calculate the Manhattan distance between the bot and the enemy
        IF ABS(enemy.position.x - bot.position.x) + ABS(enemy.position.y - bot.position.y) <= 2 THEN
            // If the distance is 2 or less, bot is in danger
            RETURN True
    // If none of the enemies are within the danger distance, return False
    RETURN False

// Function to check if a point is in between two other points
FUNCTION is_in_between(point1, point2, point3)
    // Returns True if point2 is between point1 and point3, inclusively
    RETURN point1 <= point2 AND point2 <= point3

FUNCTION get_direction(current_x, current_y, dest_x, dest_y, board)
    teleports = get_teleport_info(board.game_objects)
    diamondButton = get_diamond_button(board.game_objects)
    bots = board.bots
    PRINT("bot nih bang", bots)
    horizontal = True
    isDestDiaButton = (dest_x == diamondButton.position.x AND dest_y == diamondButton.position.y)

    IF ((is_in_between(current_x, diamondButton.position.x, dest_x) OR is_in_between(dest_x, diamondButton.position.x, current_x)) AND current_y == dest_y AND current_y == diamondButton.position.y AND NOT isDestDiaButton)
        IF current_y != board.height - 1
            RETURN (0, 1)
        ELSE
            RETURN (0, -1)
    ELSE IF ((is_in_between(current_y, diamondButton.position.y, dest_y) OR is_in_between(dest_y, diamondButton.position.y, current_y)) AND current_x == dest_x AND current_x == diamondButton.position.x AND NOT isDestDiaButton)
        IF current_x != board.width - 1
            RETURN (1, 0)
        ELSE
            RETURN (-1, 0)

    IF ((is_in_between(current_y, diamondButton.position.y, dest_y) OR is_in_between(dest_y, diamondButton.position.y, current_y)) AND (dest_x == diamondButton.position.x OR current_y == diamondButton.position.y) AND NOT isDestDiaButton)
        horizontal = False

    FOR EACH teleport IN teleports
        IF ((is_in_between(current_x, teleport.position.x, dest_x) OR is_in_between(dest_x, teleport.position.x, current_x)) AND current_y == dest_y AND current_y == teleport.position.y)
            IF current_y != board.height - 1
                RETURN (0, 1)
            ELSE
                RETURN (0, -1)
        ELSE IF ((is_in_between(current_y, teleport.position.y, dest_y) OR is_in_between(dest_y, teleport.position.y, current_y)) AND current_x == dest_x AND current_x == teleport.position.x)
            IF current_x != board.width - 1
                RETURN (1, 0)
            ELSE
                RETURN (-1, 0)

        IF (is_in_between(current_y, teleport.position.y, dest_y) OR is_in_between(dest_y, teleport.position.y, current_y)) AND (dest_x == teleport.position.x OR current_y == teleport.position.y)
            PRINT("test gan")
            horizontal = False

    delta_x = clamp(dest_x - current_x, -1, 1)
    delta_y = clamp(dest_y - current_y, -1, 1)

    IF delta_x != 0 AND horizontal
        delta_y = 0
    ELSE IF delta_y != 0 AND NOT horizontal
        delta_x = 0
    RETURN (delta_x, delta_y)


FUNCTION get_diamonds_info(game_objects)
    RETURN LIST OF obj FOR EACH obj IN game_objects IF obj.type == "DiamondGameObject"

FUNCTION get_teleport_info(game_objects)
    RETURN LIST OF obj FOR EACH obj IN game_objects IF obj.type == "TeleportGameObject"

FUNCTION get_time_left(game_objects)
    FOR EACH item IN game_objects
        IF item.type == "BotGameObject"
            RETURN item.properties.milliseconds_left

FUNCTION get_closest_diamond(pos, diamonds)
    RETURN MINIMUM OF diamonds USING KEY:
        ABS(d.position.x - pos.x) + ABS(d.position.y - pos.y)

FUNCTION check_if_should_go_for_diamond_button(bot, game_objects, diamonds)
    RETURN (
        get_time_to_location(bot.position, get_closest_diamond_position(bot.position, diamonds)) -
        get_time_to_location(bot.position, get_diamond_button(game_objects).position)
        > 5000
    )


FUNCTION get_diamonds_info(game_objects)
    RETURN [obj FOR obj IN game_objects IF obj.type == "DiamondGameObject"]

FUNCTION get_teleport_info(game_objects)
    RETURN [obj FOR obj IN game_objects IF obj.type == "TeleportGameObject"]

FUNCTION get_time_left(game_objects)
    FOR item IN game_objects
        IF item.type == "BotGameObject"
            RETURN item.properties.milliseconds_left

FUNCTION get_closest_diamond(pos, diamonds)
    RETURN MIN(diamonds, KEY=lambda d: ABS(d.position.x - pos.x) + ABS(d.position.y - pos.y))

FUNCTION check_if_should_go_for_diamond_button(bot, game_objects, diamonds)
    RETURN (get_time_to_location(bot.position, get_closest_diamond_position(bot.position, diamonds)) - get_time_to_location(bot.position, get_diamond_button(game_objects).position) > 5000)

FUNCTION get_diamond_button(game_objects)
    FOR item IN game_objects
        IF item.type == "DiamondButtonGameObject"
            RETURN item

FUNCTION get_closest_diamond_position(pos, diamonds)
    RETURN get_closest_diamond(pos, diamonds).position

FUNCTION get_closest_blue_diamond_position(pos, diamonds)
    RETURN MIN([d FOR d IN diamonds IF d.properties.points == 1], KEY=lambda d: ABS(d.position.x - pos.x) + ABS(d.position.y - pos.y)).position

FUNCTION get_closest_bot(pos, bots)
    RETURN MIN(bots, KEY=lambda b: ABS(b.position.x - pos.x) + ABS(b.position.y - pos.y))

FUNCTION get_closest_bot_to_diamond(diamond_pos, bots)
    RETURN MIN(bots, KEY=lambda b: ABS(b.position.x - diamond_pos.x) + ABS(b.position.y - diamond_pos.y))

FUNCTION get_ranked_robots(bots)
    RETURN SORTED(bots, KEY=lambda b: b.properties.diamonds, REVERSE=True)

FUNCTION get_rank(bots, bot_id)
    sorted_bots = SORTED(bots, KEY=lambda b: b.properties.diamonds, REVERSE=True)
    FOR i, bot IN ENUMERATE(sorted_bots)
        IF bot.id == bot_id
            RETURN i + 1

FUNCTION get_time_to_location(current, dest)
    RETURN 1000 * (ABS(dest.x - current.x) + ABS(dest.y - current.y))


FUNCTION position_equals(a, b)
    RETURN a.x == b.x AND a.y == b.y

FUNCTION clamp(n, smallest, largest)
    RETURN MAX(smallest, MIN(n, largest))

FUNCTION killable(my_bot, enemies, diamonds)
    FOR enemy IN enemies
        my_bot_closest_diamond = get_closest_diamond_position(my_bot.position, diamonds)
        enemy_closest_diamond = get_closest_diamond_position(enemy.position, diamonds)
        IF NOT position_equals(my_bot_closest_diamond, enemy_closest_diamond)
            CONTINUE
        ELSE IF get_time_to_location(my_bot.position, my_bot_closest_diamond) - get_time_to_location(enemy.position, enemy_closest_diamond) == 1000
            RETURN True
    RETURN False

